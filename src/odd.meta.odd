program = statements ";"?;

statements = statement (";" statement)*;

statement = export | statement-body;

export = "export" statement-body;

statement-body =
	type-declaration
	| declaration
	| expression;

type-declaration = .identifier type-parameters? "::" type;

type-parameters = .identifier+

type = type-function;

type-function =
	type-union "->" type-function
	| type-union;

type-union =
	type-intersection "|" type-union
	| type-intersection;

type-intersection =
	type-application "&" type-intersection
	| type-application;

;; TODO: Allow direct left-recursion
;; and treat it as a
;; (left-associative) sequence?
type-application =
	type-application type-application
	| type-access;

type-access =
	type-value "." type-access
	| type-value;

type-value =
	"{" (type-field ("," type-field)*)? "}"
	| "[" (type ("," type)*)? "]"
	| literal
	| "(" type ")";

type-field = literal+ "::" type;

literal =
	.identifier
	| .constant
	| .string
	| .number
	| .operator;

declaration =
	function-declaration
	| value-declaration
	| operator-declaration;

function-declaration = .identifier expression "=" expression;

value-declaration = .identifier "=" expression;

operator-declaration = parameter .operator parameter "=" expression;

expression = (match-expression | if-expression | lambda | operation) where-clause?;

match-expression = "match" expression match+;

match = type "=>" expression;

if-expression = "if" expression "then" expression ("else" expression)?;

lambda = parameter "->" expression;

operation = application (.operator operation)?;

application = access application?;

access = value ("." value)*

value =
	map
	| list
	| literal
	| "(" expression ")";

where-clause = "where" declaration ("," declaration)*

map = "{" (field ("," field)*)? "}";

field = key "=" expression;

list = "[" (expression ("," expression)*)? "]";

;; TODO: (referencable) capture
;; groups syntax
;; TODO: ignored groups syntax