program = statements ";"?;

statements = statement (";" statement)*;

statement = export | statement-body;

export = "export" statement;

statement-body =
	type-declaration
	| declaration
	| expression;

type-declaration = .identifier type-parameter* "::" type;

type-parameter =
	.identifier
	| "(" type .identifier ")";

type = type-function;

type-function = type-union ("->" type-function)?;

type-union = type-intersection ("|" type-union)?;

type-intersection = type-application ("&" type-intersection)?;

type-application = type-access type-application?;

type-access = type-value ("." type-access)*;

type-value =
	"{" type-field* "}"
	| "[" type* "]"
	| "(" type ")"
	| literal;

type-field = type-key "::" type;

type-key = literal+;

literal =
	.identifier
	| .constant
	| .string
	| .number
	| .operator;

declaration =
	value-declaration
	| operator-declaration;

value-declaration = .identifier parameter* "=" expression;

operator-declaration = parameter .operator parameter "=" expression;

parameter = literal | "(" type literal ")";

expression = (match-expression | if-expression | lambda | operation) where-clause?;

match-expression = "match" expression match+;

match = type "=>" expression;

if-expression = "if" expression "then" expression ("else" expression)?;

lambda = parameter "->" expression;

operation = application (.operator operation)?;

application = access application?;

access = value ("." value)*

value =
	map
	| list
	| "(" expression ")"
	| literal;

where-clause = "where" declaration ("," declaration)*

map = "{" (field ("," field)*)? "}";

field = key "=" expression;

list = "[" (expression ("," expression)*)? "]";

;; TODO: Think of a good way to describe
;; rules that should yield nodes.
;; Something like rule1 = label: rule2
;; and labeled-rule := rule.
;; TODO: Think of a way to indicate when a
;; matched rule shouldn't yield any value.
;; Something like !rule or (?:rule) or -rule?