# To Do
_Here be feature propositions._ ðŸ—ºï¸

## ToDo Feature Format
Adding a ToDo Feature is easy and encouraged. Just provide a title, and a concise feature description.

**Any proposition in the form of a pull request will be documented in this file as well.**

Please be as code-agnostic in writing as possible: _don't think about how to solve `X` in language `Y`_, but rather _think about how to solve `X` with (human) logic, and translate that into language `Y`_.

```md
### Feature Title
_`By:`_ @author[, @contributor[, @implementor]]
##### STATUS: `Feature status.` Should be one of [Pending, Planned, Started, Done, Rejected].

Concise description of feature.

--- Seperator line for document structure preservation
```

Note that concise doesn't mean _"as brief as possible"_. It means _"as complete as possible within the confines of clarity and brevity"_.

When creating a ToDo Feature, sign your `@name` after the _`By:`_ tag. Also sign your name if you altered the proposition or implemented it. If you helped in any stage of the proposal you can consider signing also; give credit where credit is due.

---

### 1: ~~Rewrite entire compiler architecture to be (more) modular~~
_`By:`_ @maanlamp
##### STATUS: `Done`

The old architecture does not allow scaling in any way. All features must be hacked into the code. Even the cleanest code is a chore to traverse if all you want to do is add a feature, or just update a certain part of the compiler. By transitioning to a more plugin-based architecture, we explicitly design all parts of the language as plugins, allowing for easy additions and removals, as well as a inherently easy-to-maintain structure.

---

### 2: ~~Rewrite lexer to use modular grammar~~
_`By:`_ @maanlamp
##### STATUS: `Done`

The old architecture does not allow scaling in any way. All features must be hacked into the code. Even the cleanest code is a chore to traverse if all you want to do is add a feature, or just update a certain part of the compiler. By transitioning to a more plugin-based architecture, we explicitly design all parts of the language as plugins, allowing for easy additions and removals, as well as a inherently easy-to-maintain structure.

---

### 3: ~~Log the correct unidentifiable lexeme when throwing an error~~
_`By:`_ @maanlamp
##### STATUS: `Done`

When the lexer has gone through all defined grammars but finds none, it throws an error. Currently it just says that the unidentifiable lexeme and the _entire_ string after it are all unidentifiable. The lexeme should be cut off at a point where actually no grammar can be found.

---

### 4: ~~Colourise tokens in the line that contains a lexical error~~
_`By:`_ @maanlamp
##### STATUS: `Done`

The lexer now logs the correct line when a lexical error was found, but that line is just white. Syntax colouring should help identify the error better.

---

### 5: Make preprocessor recognise directives
_`By:`_ @maanlamp
##### STATUS: `Started`

The preprocessor does not work yet. In order for it to work, it must recognise the beginning and ending of preprocessor directives from tokens generated by the lexer.

---

### 6: Assigning multiple lexical tokens with one regex
_`By:`_ @maanlamp
##### STATUS: `pending`

As of now, you can only assign a single token that complies to a single rule, but regular expressions can give back countless matches. I should look into a syntax for assigning multiple tokens with one regex, e.g:

```js
const Lexer = require("./Lexer");
const lexer = new Lexer();
lexer.rule({
  0: "builtin math",
  1: "operator",
  2: "builtin math method"
}, /\b(Math)(.?)(floor|round|ceil)\b/);
//or
lexer.rule(["builtin math", "operator", "builtin math method"], /\b(Math)(.?)(floor|round|ceil)\b/);
```

---

### 7: Show only the error-causing lexeme when an error occurs while lexing
_`By:`_ @maanlamp
> Related to [ToDo 3](#3-log-the-correct-unidentifiable-lexeme-when-throwing-an-error)
##### STATUS: `planned`

When an error occurs, the cause of the error will be stripped out of the input, and will be used for error logging. Any other lexeme that also complies to the regex, that will be created from the cause of the error, is also stripped and preserved (erroneously). Fix pls.

---

### 8: Make the entire processor pipeline work with streams
_`By:`_ @maanlamp
##### STATUS: `planned`

For testing, I'm processing small files. When the language will be used in bigger projects, it will not scale if it has to load and save everything into memory. Streams were introduced exactly for this use case, so we should use them.

---

### 9: Turn explicitly defined preprocessor into processor plugin
_`By:`_ @maanlamp
##### STATUS: `started`

Since a preprocessor is not a standard part of a processor (e.g. not all processors use a preprocessor), we should embrace the plugin-based architecture and make a plugin out of it. Or several!

---

### 10: Have seperate pre- and post-AST plugin stages
_`By:`_ @maanlamp
##### STATUS: `planned`

In order for some plugins (such as the preprocessor) to work, they must be able to access the token stream instead of an AST. There should be a way for a plugin to choose what stage it hooks into.