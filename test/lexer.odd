Rules :: List {
	type :: String,
	pattern :: String | Regex,
	ignore :: Boolean | nothing
};

Location :: [ Number, Number ];

Token :: {
	type :: String,
	lexeme :: String,
	location :: Location
};

Leaf :: Node | Token;

Node :: {
	type :: String,
	children :: List Leaf
};

State :: {
	grammar :: Grammar,
	input :: List Token,
	stack :: List Leaf,
	;; A type application always consists of two types.
	;; When a type needs to know two types, do we just provide tuples,
	;; or are we introducing new syntax?
	cache :: Object [ [ String, Location ], State ]
};

Success :: State & {
	ok :: true
};

Failure :: State & {
	ok :: false,
	reason :: String
};

Result :: Success | Failure;

Grammar :: Object [ `program` | String, Parser ];

Matcher :: String -> Match | nothing;

Match :: {
	type :: String,
	lexeme :: String,
	ignore :: Boolean,
	location :: Location
};

Comparison :: -1 | 0 | 1;

compare :: a -> a -> Comparison;
compare nothing b = -1;
compare a nothing = 1;
compare a b = if a > b then 1 else if a == b then 0 else -1;

compare-by :: (a -> a -> Number) -> a -> a -> Comparison;
compare-by f a b = compare (f a) (f b);

max-by :: (a -> a -> Comparison) -> a -> a -> a;
max-by f a b = if f a b >= 0 then a else b;

lex :: List Matcher -> String -> [ Token | nothing, String ];
lex matchers `` = [ nothing, `` ];
lex matchers input = [ longest, rest ] where
	longest =
		;; TODO: (apply input) gets recognised
		;; as a type application????? Fix lol
		;; TODO: application should be 
		;; left-associative but it's currently
		;; right-associative
		((map (apply input) matchers)
		|> (filter exists
		|> (fold (max-by compare-by (m -> size m.lexeme))) nothing)), ;; this works because when `m` is `nothing`, any property you try to access will also be `nothing`, and `size nothing = 0`.
	rest = (drop (size longest.lexeme)) input;

lexer :: Rules -> String -> List Token;
;; TODO: Implement

Parser :: State -> Result;

parser :: Grammar -> List Token -> Result.stack;